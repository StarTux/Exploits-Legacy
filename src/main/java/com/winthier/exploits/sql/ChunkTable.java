package com.winthier.exploits.sql;

import com.avaje.ebean.validation.NotNull;
import com.winthier.exploits.WorldCoordinate;
import com.winthier.exploits.WorldCoordinate;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.OneToOne;
import javax.persistence.Table;
import javax.persistence.UniqueConstraint;
import lombok.Getter;
import lombok.Setter;

@Entity
@Table(name="chunks",
       uniqueConstraints=@UniqueConstraint(columnNames={"world_id", "x", "y", "z"}))
@Getter
@Setter
public class ChunkTable {
    final static Map<WorldCoordinate, ChunkTable> cache = new HashMap<>();
    
    @Id
    private Integer id;

    @NotNull
    @ManyToOne
    private WorldTable world;

    @NotNull
    private Integer x;

    @NotNull
    private Integer y;

    @NotNull
    private Integer z;

    @OneToOne(mappedBy="chunk", optional=true, fetch=FetchType.LAZY)
    private PlayerPlacedBlocksTable playerPlacedBlocks;

    private static ChunkTable find(WorldTable world, int x, int y, int z) {
        if (world == null) throw new NullPointerException("World cannot be null");
        if (y < 0) return null;
        List<ChunkTable> list = DB.get().find(ChunkTable.class).where().eq("world", world).eq("x", x).eq("y", y).eq("z", z).findList();
        if (list.isEmpty()) return null;
        return list.get(0);
    }

    private static ChunkTable findOrCreate(WorldTable world, int x, int y, int z) {
        if (world == null) throw new NullPointerException("World cannot be null");
        ChunkTable result = find(world, x, y, z);
        if (result == null) {
            result = new ChunkTable();
            result.setWorld(world);
            result.setX(x);
            result.setY(y);
            result.setZ(z);
            DB.get().save(result);
        }
        return result;
    }

    // This function may store null in the cache. This is
    // important so a non-existant cache does not continually
    // trigger database requests.
    static ChunkTable find(WorldCoordinate coordinate) {
        if (coordinate == null) throw new NullPointerException("coordinate cannot be null");
        ChunkTable result;
        if (cache.containsKey(coordinate)) return cache.get(coordinate);
        WorldTable world = WorldTable.findOrCreate(coordinate.getWorld());
        result = find(world, coordinate.getX(), coordinate.getY() , coordinate.getZ());
        cache.put(coordinate, result); // might put null
        return result;
    }

    static ChunkTable findOrCreate(WorldCoordinate coordinate) {
        if (coordinate == null) throw new NullPointerException("coordinate cannot be null");
        ChunkTable result;
        result = cache.get(coordinate);
        if (result != null) return result;
        WorldTable world = WorldTable.findOrCreate(coordinate.getWorld());
        result = findOrCreate(world, coordinate.getX(), coordinate.getY() , coordinate.getZ());
        cache.put(coordinate, result);
        return result;
    }

    // Does NOT use cache!
    static List<ChunkTable> findAllInWorld(String worldName) {
        WorldTable world = WorldTable.find(worldName);
        if (world == null) return java.util.Collections.<ChunkTable>emptyList();
        return DB.get().find(ChunkTable.class).where().eq("world", world).findList();
    }
}
