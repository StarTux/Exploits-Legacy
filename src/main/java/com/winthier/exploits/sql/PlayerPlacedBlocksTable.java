package com.winthier.exploits.sql;

import com.avaje.ebean.ValidationException;
import com.avaje.ebean.validation.NotNull;
import com.winthier.exploits.Coordinate;
import com.winthier.exploits.WorldCoordinate;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.Id;
import javax.persistence.Lob;
import javax.persistence.OneToOne;
import javax.persistence.Table;
import javax.persistence.UniqueConstraint;
import javax.persistence.Version;
import lombok.Getter;
import lombok.Setter;
import lombok.val;

@Entity
@Table(name="player_placed_blocks",
       uniqueConstraints=@UniqueConstraint(columnNames={"chunk_id"}))
@Getter
@Setter
public class PlayerPlacedBlocksTable {
    final static Map<WorldCoordinate, PlayerPlacedBlocksTable> cache = new HashMap<>();
    private final static int LENGTH = 16*16*16;
    private final static int BYTE_LENGTH = 16*16*16/6;
    
    @Id
    private Integer id;

    @NotNull
    @OneToOne(optional=false, fetch=FetchType.LAZY)
    private ChunkTable chunk;
    
    @NotNull
    @Lob
    private byte[] data;

    @Version
    private Date modified;

    private transient BitSet bits = new BitSet();
    private transient boolean dirty = false;
    private transient long accessed = System.currentTimeMillis();

    private void cook() {
        byte[] newData = bits.toByteArray();
        if (newData.length > BYTE_LENGTH) {
            newData = Arrays.copyOfRange(data, 0, BYTE_LENGTH);
        }
        setData(newData);
    }

    private void uncook() {
        if (getData() == null) {
            bits = new BitSet(LENGTH);
        } else {
            bits = BitSet.valueOf(getData());
        }
    }

    static PlayerPlacedBlocksTable find(ChunkTable chunk) {
        PlayerPlacedBlocksTable result;
        result = DB.get().find(PlayerPlacedBlocksTable.class).where().eq("chunk", chunk).findUnique();
        if (result != null) result.uncook();
        return result;
    }

    static PlayerPlacedBlocksTable findOrCreate(ChunkTable chunk) {
        PlayerPlacedBlocksTable result = find(chunk);
        if (result == null) {
            result = new PlayerPlacedBlocksTable();
            result.setChunk(chunk);
            result.uncook();
        }
        return result;
    }

    // This function may store null in the cache. This is
    // important so non-existing data don't trigger continuous
    // database requests.
    public static PlayerPlacedBlocksTable find(WorldCoordinate coordinate) {
        PlayerPlacedBlocksTable result;
        if (cache.containsKey(coordinate)) return cache.get(coordinate);
        ChunkTable chunk = ChunkTable.find(coordinate);
        if (chunk == null) return null;
        result = find(chunk);
        cache.put(coordinate, result);
        return result;
    }

    public static PlayerPlacedBlocksTable findOrCreate(WorldCoordinate coordinate) {
        PlayerPlacedBlocksTable result;
        result = cache.get(coordinate);
        if (result != null) return result;
        ChunkTable chunk = ChunkTable.findOrCreate(coordinate);
        result = findOrCreate(chunk);
        cache.put(coordinate, result);
        return result;
    }

    public boolean save() {
        if (!dirty) return false;
        cook();
        try {
            DB.get().save(this);
        } catch (ValidationException ve) {
            ve.printStackTrace();
        }
        dirty = false;
        return true;
    }

    public boolean isOld() {
        if (dirty) return false;
        if (System.currentTimeMillis() - accessed < 1000L * 60 * 10) return false;
        return true;
    }

    private int index(int x, int y, int z) {
        if (x < 0 || x >= 16) throw new IllegalArgumentException("x out of bounds: " + x);
        if (y < 0 || y >= 16) throw new IllegalArgumentException("y out of bounds: " + y);
        if (z < 0 || z >= 16) throw new IllegalArgumentException("z out of bounds: " + z);
        return y*16*16 + z*16 + x;
    }

    private void bump() {
        accessed = System.currentTimeMillis();
    }

    private void stain() {
        dirty = true;
    }

    public boolean isPlayerPlaced(int x, int y, int z) {
        bump();
        return bits.get(index(x, y, z));
    }

    public void setPlayerPlaced(int x, int y, int z, boolean value) {
        if (isPlayerPlaced(x, y, z) == value) return;
        bits.set(index(x, y, z), value);
        stain();
    }

    public boolean isPlayerPlaced(Coordinate coordinate) {
        return isPlayerPlaced(coordinate.getX(), coordinate.getY(), coordinate.getZ());
    }

    public void setPlayerPlaced(Coordinate coordinate, boolean value) {
        setPlayerPlaced(coordinate.getX(), coordinate.getY(), coordinate.getZ(), value);
    }

    public static void saveAll() {
        int saveCount = 0;
        val iter = cache.entrySet().iterator();
        while (iter.hasNext()) {
            val item = iter.next();
            PlayerPlacedBlocksTable row = item.getValue();
            // Will only save if dirty
            if (row == null) continue;
            if (row.save()) saveCount += 1;
            if (row.isOld()) iter.remove();
        }
        if (saveCount > 0) {
            System.out.println("[Exploits] Saved " + saveCount + " chunk(s) to the database");
        }
    }
}
