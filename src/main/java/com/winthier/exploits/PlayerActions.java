package com.winthier.exploits;

import com.winthier.exploits.sql.PlayerIndexTable;
import com.winthier.exploits.sql.PlayerLocationTable;
import java.util.ArrayList;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import lombok.Getter;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.Setter;

/**
 * This framework keeps track of recent player actions, such as
 * block edits or entities, see the enum PlayerAction.
 */
@RequiredArgsConstructor
public class PlayerActions implements Exploit {
    static final int LOG_SIZE = 1024;
    static final long DEBUG_SECONDS = 60;
    class ActionData {
        final UUID player;
        final PlayerAction action;
        PlayerIndexTable index = null;
        PlayerLocationTable[] locations = null;
        ActionData(UUID player, PlayerAction action) {
            this.player = player;
            this.action = action;
            index = PlayerIndexTable.findOrCreate(player, action);
            locations = new PlayerLocationTable[LOG_SIZE];
            for (PlayerLocationTable row : PlayerLocationTable.findAll(player, action)) {
                if (row.getPlayerIndex() < LOG_SIZE) locations[row.getPlayerIndex()] = row;
            }
        }
        void next() {
            int nextIndex = (index.getPlayerIndex() + 1) % LOG_SIZE;
            index.setPlayerIndex(nextIndex);
            dirties.add(index);
        }
        void setLocation(@NonNull WorldCoordinate location) {
            if (locations == null) throw new NullPointerException("Locations is null for action " + action);
            int i = index.getPlayerIndex();
            if (locations[i] == null) locations[i] = PlayerLocationTable.findOrCreate(player, action, i, location);
            else locations[i].setLocation(location);
            dirties.add(locations[i]);
        }
    }
    @RequiredArgsConstructor
    class PlayerData {
        final UUID player;
        long accessed = 0L;
        final Map<PlayerAction, ActionData> actions = new EnumMap<PlayerAction, ActionData>(PlayerAction.class);
        ActionData getAction(PlayerAction action) {
            accessed = System.currentTimeMillis();
            ActionData result = actions.get(action);
            if (result == null) {
                result = new ActionData(player, action);
                actions.put(action, result);
            }
            return result;
        }
        boolean isOld() {
            return System.currentTimeMillis() - accessed >= 1000L * 60L * 10L;
        }
    }
    @RequiredArgsConstructor
    class DelayedAction {
        final UUID player;
        final PlayerAction action;
        final WorldCoordinate location;
        void insert() {
            ActionData data = getPlayer(player).getAction(action);
            data.setLocation(location);
            data.next();
        }
    }
    
    private final Exploits exploits;
    private final Map<UUID, PlayerData> players = new HashMap<>();
    private final Set<Object> dirties = new HashSet<>();
    private final List<DelayedAction> delayed = new ArrayList<>();

    PlayerData getPlayer(UUID uuid) {
        PlayerData result = players.get(uuid);
        if (result == null) {
            result = new PlayerData(uuid);
            players.put(uuid, result);
        }
        return result;
    }

    public void onBlockBreak(@NonNull UUID player, @NonNull WorldCoordinate location) {
        DelayedAction da = new DelayedAction(player, PlayerAction.BLOCK_BREAK, location);
        delayed.add(da);
        if (exploits.hasDebugMode(player)) {
            long seconds = DEBUG_SECONDS;
            exploits.send(player, "Broke before (%d): %s", seconds, didBreakBlockWithinSeconds(player, location, seconds));
        }
    }

    public void onBlockPlace(@NonNull UUID player, @NonNull WorldCoordinate location) {
        DelayedAction da = new DelayedAction(player, PlayerAction.BLOCK_PLACE, location);
        delayed.add(da);
        if (exploits.hasDebugMode(player)) {
            long seconds = DEBUG_SECONDS;
            exploits.send(player, "Placed before (%d): %s", seconds, didPlaceBlockWithinSeconds(player, location, seconds));
        }
    }

    public void onEntityKill(@NonNull UUID player, @NonNull WorldCoordinate location) {
        DelayedAction da = new DelayedAction(player, PlayerAction.ENTITY_KILL, location);
        delayed.add(da);
        if (exploits.hasDebugMode(player)) {
            long seconds = DEBUG_SECONDS;
            double killDistance = getKillDistanceWithinSeconds(player, location, seconds);
            exploits.send(player, "Kill distance (%d): %.01f", seconds, Math.min(999.9, killDistance));
        }
    }

    void flush() {
        for (DelayedAction da : delayed) da.insert();
        delayed.clear();
    }

    void saveAll() {
        exploits.getDatabase().save(dirties);
        dirties.clear();
        Iterator<PlayerData> iter = players.values().iterator();
        while (iter.hasNext()) {
            if (iter.next().isOld()) iter.remove();
        }
    }

    private boolean didPlaceOrBreakWithinSeconds(@NonNull UUID player, @NonNull WorldCoordinate location, long seconds, boolean place) {
        long minTime = System.currentTimeMillis() - seconds * 1000L;
        ActionData data = getPlayer(player).getAction(place ? PlayerAction.BLOCK_PLACE : PlayerAction.BLOCK_BREAK);
        for (PlayerLocationTable row : data.locations) {
            if (row == null) continue;
            if (!row.getWorld().getName().equals(location.getWorld())) continue;
            if (row.getX() != location.getX()) continue;
            if (row.getY() != location.getY()) continue;
            if (row.getZ() != location.getZ()) continue;
            if (row.getUpdated().getTime() < minTime) continue;
            return true;
        }
        return false;
    }

    public boolean didPlaceBlockWithinSeconds(UUID player, WorldCoordinate location, long seconds) {
        return didPlaceOrBreakWithinSeconds(player, location, seconds, true);
    }

    public boolean didBreakBlockWithinSeconds(UUID player, WorldCoordinate location, long seconds) {
        return didPlaceOrBreakWithinSeconds(player, location, seconds, false);
    }

    public WorldCoordinate getAverageKillLocationWithinSeconds(@NonNull UUID player, @NonNull String worldName, long seconds) {
        int x = 0, y = 0, z = 0, count = 0;
        long minTime = System.currentTimeMillis() - seconds * 1000L;
        ActionData data = getPlayer(player).getAction(PlayerAction.ENTITY_KILL);
        for (PlayerLocationTable row : data.locations) {
            if (row == null) continue;
            if (row.getUpdated().getTime() < minTime) continue;
            if (!worldName.equals(row.getWorld().getName())) continue;
            x += row.getX();
            y += row.getY();
            z += row.getZ();
            count += 1;
        }
        if (count == 0) return null;
        x /= count;
        y /= count;
        z /= count;
        return WorldCoordinate.of(worldName, x, y, z);
    }

    public double getKillDistanceWithinSeconds(@NonNull UUID player, @NonNull WorldCoordinate location, long seconds) {
        WorldCoordinate average = getAverageKillLocationWithinSeconds(player, location.getWorld(), seconds);
        if (average == null) return Double.MAX_VALUE;
        return average.distance(location);
    }

    public double getKillDistancePercentageWithinSeconds(@NonNull UUID player, @NonNull WorldCoordinate location, long seconds, double full) {
        if (full <= 0.0) return 0.0;
        return Math.min(1.0, getKillDistanceWithinSeconds(player, location, seconds) / full);
    }
    
    @Override
    public void onEnable() {
    }

    @Override
    public void onDisable() {
        flush();
        saveAll();
        players.clear();
    }

    @Override
    public void onTick() {
        flush();
        if (exploits.getTicksLived() % (20L * 60L) == 0L) saveAll();
    }
}
