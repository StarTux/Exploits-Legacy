package com.winthier.exploits;

import com.winthier.exploits.sql.PlayerBlockTable;
import com.winthier.exploits.sql.PlayerEntityTable;
import com.winthier.exploits.sql.PlayerIndexTable;
import com.winthier.exploits.sql.PlayerLocationTable;
import java.util.ArrayList;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import lombok.Getter;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.Setter;

/**
 * This framework keeps track of recent player actions, such as
 * block edits or entities, see the enum PlayerAction.
 */
@RequiredArgsConstructor
public class PlayerActions implements Exploit {
    static final int LOG_SIZE = 1024;
    class ActionData {
        final UUID player;
        final PlayerAction action;
        PlayerIndexTable index = null;
        PlayerLocationTable[] locations = null;
        PlayerBlockTable[] blocks = null;
        PlayerEntityTable[] entities = null;
        ActionData(UUID player, PlayerAction action) {
            this.player = player;
            this.action = action;
            index = PlayerIndexTable.findOrCreate(player, action);
            locations = new PlayerLocationTable[LOG_SIZE];
            for (PlayerLocationTable row : PlayerLocationTable.findAll(player, action)) {
                if (row.getIndex() < LOG_SIZE) locations[row.getIndex()] = row;
            }
            switch (action) {
            case BLOCK_BREAK: case BLOCK_PLACE:
                blocks = new PlayerBlockTable[LOG_SIZE];
                for (PlayerBlockTable row : PlayerBlockTable.findAll(player, action)) {
                    if (row.getIndex() < LOG_SIZE) blocks[row.getIndex()] = row;
                }
                break;
            case ENTITY_KILL:
                entities = new PlayerEntityTable[LOG_SIZE];
                for (PlayerEntityTable row : PlayerEntityTable.findAll(player, action)) {
                    if (row.getIndex() < LOG_SIZE) entities[row.getIndex()] = row;
                }
                break;
            }
        }
        void next() {
            int nextIndex = (index.getIndex() + 1) % LOG_SIZE;
            index.setIndex(nextIndex);
        }
        void setLocation(@NonNull WorldCoordinate location) {
            if (locations == null) throw new NullPointerException("Locations is null for action " + action);
            int i = index.getIndex();
            if (locations[i] == null) locations[i] = PlayerLocationTable.findOrCreate(player, action, i, location);
            else locations[i].setLocation(location);
            dirties.add(locations[i]);
        }
        void setBlock(int blockID, int blockData) {
            if (blocks == null) throw new NullPointerException("Blocks is null for action " + action);
            int i = index.getIndex();
            if (blocks[i] == null) blocks[i] = PlayerBlockTable.findOrCreate(player, action, i, blockID, blockData);
            else blocks[i].setBlock(blockID, blockData);
            dirties.add(blocks[i]);
        }
        void setEntity(String entityType) {
            if (entities == null) throw new NullPointerException("Entities is null for action " + action);
            int i = index.getIndex();
            if (entities[i] == null) entities[i] = PlayerEntityTable.findOrCreate(player, action, i, entityType);
            else entities[i].setEntity(entityType);
            dirties.add(entities[i]);
        }
    }
    @RequiredArgsConstructor
    class PlayerData {
        final UUID player;
        long accessed = 0L;
        final Map<PlayerAction, ActionData> actions = new EnumMap<PlayerAction, ActionData>(PlayerAction.class);
        ActionData getAction(PlayerAction action) {
            accessed = System.currentTimeMillis();
            ActionData result = actions.get(action);
            if (result == null) {
                result = new ActionData(player, action);
                actions.put(action, result);
            }
            return result;
        }
        boolean isOld() {
            return System.currentTimeMillis() - accessed >= 1000L * 60L * 10L;
        }
    }
    @RequiredArgsConstructor
    class DelayedAction {
        final UUID player;
        final PlayerAction action;
        WorldCoordinate location = null;
        Integer blockID = null;
        int blockData = 0;
        String entityType = null;
        void insert() {
            ActionData data = getPlayer(player).getAction(action);
            if (location != null) data.setLocation(location);
            if (blockID != null) data.setBlock(blockID, blockData);
            if (entityType != null) data.setEntity(entityType);
            data.next();
        }
    }
    
    private final Exploits exploits;
    private final Map<UUID, PlayerData> players = new HashMap<>();
    private final Set<Object> dirties = new HashSet<>();
    private final List<DelayedAction> delayed = new ArrayList<>();

    PlayerData getPlayer(UUID uuid) {
        PlayerData result = players.get(uuid);
        if (result == null) {
            result = new PlayerData(uuid);
            players.put(uuid, result);
        }
        return result;
    }

    public void onBlockBreak(@NonNull UUID player, @NonNull WorldCoordinate location, int blockID, int blockData) {
        DelayedAction da = new DelayedAction(player, PlayerAction.BLOCK_BREAK);
        da.location = location;
        da.blockID = blockID;
        da.blockData = blockData;
        delayed.add(da);
    }

    public void onBlockPlace(@NonNull UUID player, @NonNull WorldCoordinate location, int blockID, int blockData) {
        DelayedAction da = new DelayedAction(player, PlayerAction.BLOCK_PLACE);
        da.location = location;
        da.blockID = blockID;
        da.blockData = blockData;
        delayed.add(da);
    }

    public void onEntityKill(@NonNull UUID player, @NonNull WorldCoordinate location, String entityType) {
        DelayedAction da = new DelayedAction(player, PlayerAction.ENTITY_KILL);
        da.location = location;
        da.entityType = entityType;
        delayed.add(da);
    }

    void flush() {
        for (DelayedAction da : delayed) da.insert();
        delayed.clear();
    }

    void saveAll() {
        exploits.getDatabase().save(dirties);
        dirties.clear();
        Iterator<PlayerData> iter = players.values().iterator();
        while (iter.hasNext()) {
            if (iter.next().isOld()) iter.remove();
        }
    }

    public boolean didPlaceBlockWithinSeconds(@NonNull UUID player, @NonNull WorldCoordinate location, long seconds) {
        long minTime = System.currentTimeMillis() - seconds * 1000L;
        ActionData data = getPlayer(player).getAction(PlayerAction.BLOCK_PLACE);
        for (PlayerLocationTable row : data.locations) {
            if (row == null) continue;
            if (!row.getWorld().getName().equals(location.getWorld())) continue;
            if (row.getX() != location.getX()) continue;
            if (row.getY() != location.getY()) continue;
            if (row.getZ() != location.getZ()) continue;
            if (row.getUpdated().getTime() < minTime) continue;
            return true;
        }
        return false;
    }

    private WorldCoordinate getAverageKillLocationWithinSeconds(@NonNull UUID player, @NonNull String worldName, long seconds) {
        int x = 0, y = 0, z = 0, count = 0;
        long minTime = System.currentTimeMillis() - seconds * 1000L;
        ActionData data = getPlayer(player).getAction(PlayerAction.ENTITY_KILL);
        for (PlayerLocationTable row : data.locations) {
            if (row == null) continue;
            if (row.getUpdated().getTime() < minTime) continue;
            if (!worldName.equals(row.getWorld().getName())) continue;
            x += row.getX();
            y += row.getY();
            z += row.getZ();
            count += 1;
        }
        if (count == 0) return null;
        x /= count;
        y /= count;
        z /= count;
        return WorldCoordinate.of(worldName, x, y, z);
    }

    public boolean testKillDistanceWithinSeconds(@NonNull UUID player, @NonNull WorldCoordinate location, int minKillDistance, long seconds) {
        WorldCoordinate average = getAverageKillLocationWithinSeconds(player, location.getWorld(), seconds);
        if (average == null) return true;
        return average.distanceSquared(location) >= minKillDistance * minKillDistance;
    }

    public int getKillDistanceWithinSeconds(@NonNull UUID player, @NonNull WorldCoordinate location, long seconds) {
        WorldCoordinate average = getAverageKillLocationWithinSeconds(player, location.getWorld(), seconds);
        if (average == null) return -1;
        return (int)average.distance(location);
    }

    @Override
    public void onEnable() {
    }

    @Override
    public void onDisable() {
        flush();
        saveAll();
        players.clear();
    }

    @Override
    public void onTick() {
        flush();
        if (exploits.getTicksLived() % (20L * 60L) == 0L) saveAll();
    }
}
